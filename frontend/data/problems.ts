import { Problem } from "./types";

// ═══════════════════════════════════════════════════════════════
// PLACEHOLDER PROBLEMS — will be replaced with full USACO catalog
// These conform to the new enhanced Problem type with reasoning
// ═══════════════════════════════════════════════════════════════

export const problems: Problem[] = [
  // ── BRONZE ──────────────────────────────────────────────────
  {
    id: "bronze-fence-segments",
    title: "Fence Painting",
    division: "bronze",
    concepts: ["simulation", "rectangle-geometry"],
    difficulty: 1,
    source: "USACO Bronze, December 2015, Problem 1",
    usacoUrl: "http://usaco.org/index.php?page=viewproblem2&cpid=567",
    contestId: "dec15",
    problemNumber: 1,
    description: "Farmer John is painting two segments of a fence along a number line. Determine the total length of fence that is painted, counting overlap only once.",
    inputFormat: "Four integers A, B, C, D on separate lines (0 ≤ A < B ≤ 100, 0 ≤ C < D ≤ 100).",
    outputFormat: "A single integer: the total painted length.",
    sampleInput: "2\n5\n4\n8",
    sampleOutput: "6",
    constraints: "0 ≤ A < B ≤ 100, 0 ≤ C < D ≤ 100",
    reasoning: {
      classify: "This is an interval overlap problem — two segments on a number line with possible overlap.",
      keyInsight: "Total painted = length1 + length2 - overlap. Overlap = max(0, min(B,D) - max(A,C)).",
      variables: ["segment 1 start/end (A,B)", "segment 2 start/end (C,D)", "overlap length"],
      approach: "Compute each segment's length, compute overlap using min/max, subtract overlap from total.",
      complexity: "O(1) — just arithmetic on 4 values.",
      edgeCases: ["Segments don't overlap at all (overlap formula must return 0, not negative)", "Segments are identical (overlap = full length)", "One segment contains the other"],
      whyThisWorks: "The inclusion-exclusion principle: |A ∪ B| = |A| + |B| - |A ∩ B|. The max(0,...) ensures we don't get negative overlap when segments are disjoint.",
    },
    commonMistakes: [
      "Forgetting max(0,...) — getting negative overlap when segments are disjoint",
      "Using wrong formula for overlap (subtracting wrong endpoints)",
      "Off-by-one on inclusive vs exclusive endpoints",
    ],
    sessionId: "session-bronze-fence-segments",
    hasSession: true,
  },
  {
    id: "bronze-milk-counting",
    title: "Milk Production Log",
    division: "bronze",
    concepts: ["simulation", "arrays-maps", "sorting"],
    difficulty: 1,
    source: "Original (inspired by USACO Bronze sorting problems)",
    usacoUrl: "",
    reasoning: {
      classify: "Sorting + index tracking — sort values but need to remember original positions.",
      keyInsight: "You can't just sort the array — you need to track which original index each value came from. Use index-value pairs.",
      variables: ["array of (index, milk_value) pairs", "sorted version", "median position"],
      approach: "Pair each value with its original index. Sort by value. Find the median position. Return the original index of that element.",
      complexity: "O(N log N) for sorting.",
      edgeCases: ["N is even vs odd (different median rules)", "All cows produce same amount", "N = 1 (trivial case)"],
      whyThisWorks: "Sorting gives us ordered values, and carrying the original index lets us trace back to which cow it was.",
    },
    commonMistakes: [
      "Sorting and losing track of original indices",
      "Off-by-one on median position for even/odd N",
      "Using 0-based index when problem asks for 1-based",
    ],
    sessionId: "session-bronze-milk-counting",
    hasSession: true,
  },
  {
    id: "bronze-shell-game",
    title: "Shell Game",
    division: "bronze",
    concepts: ["simulation", "complete-search"],
    difficulty: 2,
    source: "USACO Bronze, February 2019, Problem 1",
    usacoUrl: "http://usaco.org/index.php?page=viewproblem2&cpid=891",
    contestId: "feb19",
    problemNumber: 1,
    reasoning: {
      classify: "Simulation + complete search — simulate the game for each possible starting position.",
      keyInsight: "There are only 3 possible starting positions. Try all 3, simulate the swaps for each, count correct guesses, take the max.",
      variables: ["ball position (changes with swaps)", "guess count per starting position", "swap pairs"],
      approach: "For each starting position (1,2,3): simulate all N swaps tracking ball position, count how many times ball position matches FJ's guess. Output max count.",
      complexity: "O(3N) = O(N) — three simulations of N swaps each.",
      edgeCases: ["Ball never matches any guess (output 0)", "All guesses correct for one starting position", "Swap involves the cup the ball is under"],
      whyThisWorks: "With only 3 starting positions, brute force is trivially efficient. Each simulation is independent and O(N).",
    },
    commonMistakes: [
      "Only trying one starting position instead of all 3",
      "Getting swap logic wrong (swapping values vs positions)",
      "Forgetting to reset ball position between simulations",
    ],
    sessionId: "session-bronze-shell-game",
    hasSession: true,
  },
  {
    id: "bronze-daisy-chains",
    title: "Daisy Chains",
    division: "bronze",
    concepts: ["complete-search", "simulation"],
    difficulty: 2,
    source: "USACO Bronze, February 2020, Problem 2",
    usacoUrl: "http://usaco.org/index.php?page=viewproblem2&cpid=1012",
    contestId: "feb20",
    problemNumber: 2,
    reasoning: {
      classify: "Brute force / complete search — check all O(N²) contiguous subarrays.",
      keyInsight: "For each subarray, compute the average and check if any element equals it. The average must be an integer for any element to match it exactly.",
      variables: ["subarray start index i", "subarray end index j", "running sum", "average"],
      approach: "For every pair (i,j), compute sum and average of elements i..j. Check if any element in that range equals the average. Count valid pairs.",
      complexity: "O(N³) naively, O(N²) if you maintain running sum. N ≤ 100 so either works.",
      edgeCases: ["Single flower (always photogenic — it equals its own average)", "All flowers same petals (every subarray is photogenic)", "Average is not an integer (can't match any element)"],
      whyThisWorks: "N ≤ 100 means O(N²) or even O(N³) is fast enough. We just need to check every possible contiguous group.",
    },
    commonMistakes: [
      "Forgetting that single flowers count as photogenic groups",
      "Using integer division and missing that average might not be a whole number",
      "Not checking ALL elements in range against the average (stopping at first)",
    ],
    sessionId: "session-bronze-daisy-chains",
    hasSession: false,
  },
  {
    id: "bronze-cow-tipping",
    title: "Cow Tipping",
    division: "bronze",
    concepts: ["simulation", "complete-search", "ad-hoc"],
    difficulty: 3,
    source: "USACO Bronze, January 2017, Problem 3",
    usacoUrl: "http://usaco.org/index.php?page=viewproblem2&cpid=689",
    contestId: "jan17",
    problemNumber: 3,
    reasoning: {
      classify: "Greedy / ad-hoc with a key observation — process from bottom-right corner backwards.",
      keyInsight: "Work from bottom-right to top-left. If cell (i,j) is 1, you MUST flip the rectangle (1,1)→(i,j). This greedy approach is optimal.",
      variables: ["N×N grid state", "flip count", "current cell being processed"],
      approach: "Iterate from (N,N) backwards to (1,1). If current cell is 1, flip all cells in rectangle from (1,1) to current position. Count flips.",
      complexity: "O(N⁴) — N² cells, each flip touches up to N² cells. Fine for N ≤ 10.",
      edgeCases: ["Grid already all zeros (0 operations)", "Single cell grid", "Entire grid is 1s"],
      whyThisWorks: "The bottom-right corner can only be affected by a flip that includes it. So if it's 1, we must flip. After flipping, that corner is fixed. Work backwards.",
    },
    commonMistakes: [
      "Trying to process top-left to bottom-right (wrong direction)",
      "Not realizing flips must include bottom-right corner",
      "Overcomplicating with BFS/DFS when it's purely arithmetic",
    ],
    sessionId: "session-bronze-cow-tipping",
    hasSession: false,
  },

  // ── SILVER (placeholders) ───────────────────────────────────
  {
    id: "silver-subarray-sums",
    title: "Subarray Sum Target",
    division: "silver",
    concepts: ["prefix-sums", "arrays-maps"],
    difficulty: 1,
    source: "Original (prefix sums pattern)",
    usacoUrl: "",
    reasoning: {
      classify: "Prefix sums + hash map — classic subarray sum pattern.",
      keyInsight: "If prefix[j] - prefix[i] = S, then subarray (i,j] sums to S. Use a hash map to count prefix values seen so far.",
      variables: ["prefix sum array", "hash map of prefix sum frequencies", "running count"],
      approach: "Build prefix sums. For each prefix[j], check if prefix[j]-S exists in the map. Add prefix[j] to map.",
      complexity: "O(N) time, O(N) space.",
      edgeCases: ["Negative numbers in array", "S = 0", "Entire array sums to S"],
      whyThisWorks: "Prefix sums convert subarray sum queries into subtraction. Hash map gives O(1) lookup for complement values.",
    },
    commonMistakes: ["Forgetting to initialize map with prefix[0]=0", "Off-by-one in prefix indexing"],
    sessionId: "session-silver-subarray-sums",
    hasSession: false,
  },
  {
    id: "silver-cow-search",
    title: "Aggressive Cows",
    division: "silver",
    concepts: ["binary-search", "sorting"],
    difficulty: 1,
    source: "Original (binary search on answer pattern)",
    usacoUrl: "",
    reasoning: {
      classify: "Binary search on the answer — search for the maximum minimum distance.",
      keyInsight: "Binary search on the distance D. For each D, greedily check if you can place C cows with at least D distance apart.",
      variables: ["sorted stall positions", "binary search bounds (lo, hi)", "distance being tested"],
      approach: "Sort stalls. Binary search on D. For each D, greedily place cows left-to-right skipping stalls too close.",
      complexity: "O(N log N) for sorting + O(N log(max_pos)) for binary search with greedy check.",
      edgeCases: ["Only 2 cows (answer is max distance)", "All stalls same position", "C = N (use every stall)"],
      whyThisWorks: "The feasibility function is monotonic: if D works, any smaller D also works. This makes binary search valid.",
    },
    commonMistakes: ["Forgetting to sort stalls first", "Wrong binary search bounds"],
    sessionId: "session-silver-cow-search",
    hasSession: false,
  },
  {
    id: "silver-connected-fields",
    title: "Connected Fields",
    division: "silver",
    concepts: ["flood-fill", "dfs", "bfs"],
    difficulty: 2,
    source: "Original (flood fill pattern)",
    usacoUrl: "",
    reasoning: {
      classify: "Flood fill / connected components — count distinct regions using DFS or BFS.",
      keyInsight: "Each unvisited grass cell starts a new DFS/BFS that marks all connected grass cells as visited. Count how many times you start a new search.",
      variables: ["grid", "visited array", "component count", "DFS/BFS stack/queue"],
      approach: "Iterate over all cells. When you find unvisited grass, increment count and flood fill to mark entire connected region.",
      complexity: "O(N×M) — each cell visited at most once.",
      edgeCases: ["Entire grid is grass (1 field)", "Entire grid is fences (0 fields)", "Diagonal cells NOT connected"],
      whyThisWorks: "DFS/BFS from any cell reaches exactly its connected component. Counting search initiations counts components.",
    },
    commonMistakes: ["Connecting diagonally when only horizontal/vertical counts", "Stack overflow on large grids with recursive DFS"],
    sessionId: "session-silver-connected-fields",
    hasSession: false,
  },

  // ── GOLD (placeholders) ─────────────────────────────────────
  {
    id: "gold-max-gift-value",
    title: "Maximum Gift Value",
    division: "gold",
    concepts: ["dp-knapsack"],
    difficulty: 1,
    source: "Original (0/1 knapsack pattern)",
    usacoUrl: "",
    reasoning: {
      classify: "0/1 Knapsack DP — maximize value with weight constraint, each item used at most once.",
      keyInsight: "dp[w] = max value achievable with weight capacity w. Process items in order, iterate weight backwards to prevent reuse.",
      variables: ["dp array of size W+1", "item weights and values", "current capacity"],
      approach: "Initialize dp[0..W] = 0. For each item, for w = W down to item.weight: dp[w] = max(dp[w], dp[w-item.weight] + item.value).",
      complexity: "O(N×W) time, O(W) space.",
      edgeCases: ["Item heavier than bag (skip it)", "W = 0 (can't take anything)", "All items same weight"],
      whyThisWorks: "Iterating weight backwards ensures each item is only used once per DP state. Forward iteration would allow reuse (unbounded knapsack).",
    },
    commonMistakes: ["Iterating weight forward (creates unbounded knapsack)", "Forgetting to handle items heavier than W"],
    sessionId: "session-gold-max-gift-value",
    hasSession: false,
  },
  {
    id: "gold-shortest-delivery",
    title: "Shortest Delivery Route",
    division: "gold",
    concepts: ["shortest-paths"],
    difficulty: 2,
    source: "Original (Dijkstra pattern)",
    usacoUrl: "",
    reasoning: {
      classify: "Single-source shortest path — Dijkstra's algorithm with priority queue.",
      keyInsight: "Use a min-heap to always process the closest unvisited node. Relax edges greedily.",
      variables: ["distance array", "priority queue (min-heap)", "visited set", "adjacency list"],
      approach: "Initialize dist[1]=0, all others infinity. Push (0,1) to heap. Pop minimum, relax neighbors, push improvements.",
      complexity: "O((N+M) log N) with binary heap.",
      edgeCases: ["No path exists (output -1)", "Direct edge from 1 to N", "Multiple edges between same nodes"],
      whyThisWorks: "Dijkstra's greedy choice is optimal for non-negative weights: the node with smallest tentative distance is finalized.",
    },
    commonMistakes: ["Using Dijkstra with negative weights", "Not checking if node already finalized before processing"],
    sessionId: "session-gold-shortest-delivery",
    hasSession: false,
  },
];

// ─── Helper functions ────────────────────────────────────────

export function getProblemsByDivision(division: string): Problem[] {
  return problems.filter((p) => p.division === division);
}

export function getProblemById(id: string): Problem | undefined {
  return problems.find((p) => p.id === id);
}

export function getProblemsByConcept(conceptId: string): Problem[] {
  return problems.filter((p) => p.concepts.includes(conceptId));
}
